import java_cup.runtime.*;

action code {: SymbolTable currentEnv, env; :};

terminal String ID;
terminal String INTEGER;
terminal AND, OR, NOT;
terminal LT, LE, GT, GE, EQ, NE;
terminal PLUS, MINUS, TIMES, SLASH;
terminal SEMICOLON, DOT, COMMA;
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, ASSIGN;
terminal ARGS, BOOLEAN, CLASS, ELSE, FALSE, IF, IMPORT, IN, INT, JAVA, MAIN;
terminal NEXTINT, NEW, OUT, PRINTLN, PUBLIC, RETURN, SCANNER, STATIC, STRING;
terminal SYSTEM, THIS, TRUE, UTIL, VOID, WHILE;







non terminal SymbolTable program;
non terminal Type simpleTypeName;
non terminal Declarator declarator;
non terminal classSpecifier;
non terminal declaration;
non terminal declaratorList;








non terminal classDefinitionList;
non terminal classDefinition;
non terminal memberList;
non terminal memberDeclaration;
non terminal memberDeclarator;
non terminal staticOption;
non terminal functionDefinition;
non terminal functionDeclaration;
non terminal variableDeclarationList;
non terminal variableDeclaration;
non terminal arrayDeclaration;
non terminal subscriptDeclarationList;
non terminal dimensionList;
non terminal mainDeclaration;
non terminal type;
non terminal argumentDeclarationListOption;
non terminal argumentDeclarationList;
non terminal argumentDeclaration;
non terminal compoundStatement;
non terminal statementList;
non terminal statement;
non terminal assignmentStatement;
non terminal returnStatementOption;
non terminal elseOption;
non terminal expressionListOption;
non terminal expressionList;
non terminal expression;
non terminal andExpression;
non terminal relationalExpression;
non terminal arithmeticExpression;
non terminal term;
non terminal factor;
non terminal primaryExpression;
non terminal addingOperator;
non terminal multiplyingOperator;
non terminal relationalOperator;
non terminal unaryOperator;
non terminal object;
non terminal variable;
non terminal subscriptList;
non terminal functionCall;
non terminal String classId;
non terminal String objectId;
non terminal String functionId;

start with program;





program ::= IMPORT JAVA DOT UTIL DOT TIMES SEMICOLON
            {: env = new SymbolTable (null); /* start new scope */ :}
            classDefinitionList {: RESULT = env; :} ;






classDefinitionList ::= classDefinition | classDefinitionList classDefinition ;

classDefinition ::= CLASS classId LBRACE memberList RBRACE ;

memberList ::= memberList memberDeclaration | ;

memberDeclarator ::= staticOption variableDeclaration ;

staticOption ::= STATIC | ;

functionDefinition ::= functionDeclaration LBRACE
    variableDeclarationList statementList returnStatementOption RBRACE
  | functionDeclaration LBRACE statementList returnStatementOption RBRACE
  | functionDeclaration LBRACE variableDeclarationList returnStatementOption RBRACE
  | functionDeclaration LBRACE returnStatementOption RBRACE ;












functionDeclaration ::=
    simpleTypeName:type functionId:id
    {:
      currentEnv = env;         	  /* save current env */
      env = new SymbolTable (currentEnv); /* start new scope */
    :}

    PUBLIC type functionId LPAREN argumentDeclarationListOption RPAREN

    {:
      currentEnv . enterFunc (id, type, env); /* to allow recursive calls */
    :}

  | PUBLIC STATIC type functionId LPAREN argumentDeclarationListOption RPAREN
  | mainDeclaration

  {:
  currentEnv . enterFuncCode (id, ""); /* add code to function entry */
  env = env . parent (); /* restore env */
  :};

declaration ::= classSpecifier SEMICOLON
  | declarator:decl SEMICOLON
    {:
      env . enterVar (decl . id (), decl . type ());
    :} ;

simpleTypeName ::=
    classId:id {: RESULT = new ObjectType (id, env . entry (id)); :}
  | INT {: RESULT = new IntegerType (); :} ;

declaratorList ::=
    declaratorList declarator:decl SEMICOLON
    {:
      env . enterVar (decl . id (), decl . type ());
    :}
  | ;

declarator ::=
    simpleTypeName:type objectId:id
    {:
      RESULT = new Declarator (id, type);
    :}
  | declarator:decl LBRACK INTEGER:dimension RBRACK
    {:
      RESULT = new Declarator (decl . id (),
        new ArrayType (Integer . parseInt (dimension), decl . type ()));
    :} ;











variableDeclarationList ::= variableDeclaration SEMICOLON
  | variableDeclarationList variableDeclaration SEMICOLON ;

variableDeclaration ::= type objectId
  | type objectId arrayDeclaration ;

arrayDeclaration ::= subscriptDeclarationList ASSIGN NEW INT dimensionList ;

subscriptDeclarationList ::= subscriptDeclarationList LBRACK RBRACK | ;

dimensionList ::= dimensionList LBRACK INTEGER RBRACK | LBRACK INTEGER RBRACK ;

mainDeclaration ::=
    STATIC SCANNER IN ASSIGN NEW SCANNER LPAREN SYSTEM DOT IN RPAREN SEMICOLON
    PUBLIC STATIC VOID MAIN LPAREN STRING ARGS LBRACK RBRACK RPAREN
  | PUBLIC STATIC VOID MAIN LPAREN STRING ARGS LBRACK RBRACK RPAREN ;

type ::= classId | INT | BOOLEAN ;

argumentDeclarationListOption ::= argumentDeclarationList | ;














argumentDeclarationList ::= argumentDeclarationList COMMA argumentDeclaration declarator:decl
  {:
    env . enterVar (decl . id (), decl . type ());
  :}
  | argumentDeclaration declarator:decl
  {:
    env . enterVar (decl . id (), decl . type ());
  :} ;

classSpecifier ::=
    CLASS classId:id LBRACE RBRACE
      {: env . enterClass (id, new SymbolTable (env)); :}
  | CLASS classId:id LBRACE
      {:
        currentEnv = env;                   /* save current env */
        env = new SymbolTable (currentEnv); /* start new scope */
        currentEnv . enterClass (id, env);
      :}
    PUBLIC COLON memberList RBRACE
      {:
        env = env . parent (); /* restore env */
      :} ;

memberDeclaration ::=
    memberDeclarator declarator:decl SEMICOLON
    {:
      env . enterVar (decl . id (), decl . type ());
    :}
  | functionDefinition ;












argumentDeclaration ::= type objectId subscriptDeclarationList ;

compoundStatement ::= LBRACE statementList RBRACE ;

statementList ::= statementList statement | statement ;

statement ::= compoundStatement
  | assignmentStatement SEMICOLON
  | IF LPAREN expression RPAREN statement elseOption
  | WHILE LPAREN expression RPAREN statement
  | SYSTEM DOT OUT DOT PRINTLN LPAREN expression RPAREN SEMICOLON ;

assignmentStatement ::= variable ASSIGN expression
  | variable ASSIGN NEW classId LPAREN RPAREN
  | variable ASSIGN IN DOT NEXTINT LPAREN RPAREN ;

returnStatementOption ::= RETURN expression SEMICOLON | ;

elseOption ::= ELSE statement | ;

expressionListOption ::= expressionList | ;

expressionList ::= expressionList COMMA expression | expression ;

expression ::= expression OR andExpression | andExpression ;

andExpression ::= andExpression AND relationalExpression
  | relationalExpression ;

relationalExpression ::=
    arithmeticExpression relationalOperator arithmeticExpression
  | arithmeticExpression ;

relationalOperator ::= LT | LE | GT | GE | EQ | NE ;

arithmeticExpression ::= term | arithmeticExpression addingOperator term ;

addingOperator ::= PLUS | MINUS ;

term ::= factor | term multiplyingOperator factor ;

multiplyingOperator ::= TIMES | SLASH ;

factor ::= primaryExpression | unaryOperator factor ;

unaryOperator ::= addingOperator | NOT ;

primaryExpression ::= object | INTEGER | TRUE | FALSE
  | LPAREN expression RPAREN ;

object ::= variable | functionCall ;

variable ::= THIS | objectId subscriptList | object DOT objectId subscriptList ;

subscriptList ::= subscriptList LBRACK expression RBRACK | ;

functionCall ::= functionId LPAREN expressionListOption RPAREN
  | object DOT functionId LPAREN expressionListOption RPAREN ;



















classId ::= ID:id {: RESULT = id; :} ;

objectId ::= ID:id {: RESULT = id; :} ;

functionId ::= ID:id {: RESULT = id; :} ;
