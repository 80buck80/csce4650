import java_cup.runtime.*;

action code {: SymbolTable currentEnv, env; :};

terminal String ID;
terminal String INTEGER;
terminal AND, OR, NOT;
terminal LT, LE, GT, GE, EQ, NE;
terminal PLUS, MINUS, TIMES, SLASH;
terminal COLON, SEMICOLON, DOT, COMMA;
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE, ASSIGN, INPUT, OUTPUT;
terminal CIN, CLASS, COUT, ELSE, IF, INCLUDE, INT, IOSTREAM, NAMESPACE;
terminal PUBLIC, RETURN, STD, USING, WHILE;

non terminal SymbolTable program;
non terminal externalDefinitionList;
non terminal externalDefinition;
non terminal functionDefinition;
non terminal declaration;
non terminal Type simpleTypeName;
non terminal declaratorList;
non terminal Declarator declarator;
non terminal argumentDeclarationListOption;
non terminal argumentDeclarationList;
non terminal classSpecifier;
non terminal memberList;
non terminal memberDeclaration;
non terminal compoundStatement;
non terminal statementListOption;
non terminal statementList;
non terminal statement;
non terminal assignmentStatement;
non terminal elseOption;
non terminal expressionListOption;
non terminal expressionList;
non terminal expression;
non terminal andExpression;
non terminal relationalExpression;
non terminal arithmeticExpression;
non terminal term;
non terminal factor;
non terminal primaryExpression;
non terminal addingOperator;
non terminal multiplyingOperator;
non terminal relationalOperator;
non terminal unaryOperator;
non terminal object;
non terminal variable;
non terminal classMember;
non terminal subscriptList;
non terminal functionCall;
non terminal String classId;
non terminal String objectId;
non terminal String functionId;

start with program;

program ::= 
    INCLUDE IOSTREAM USING NAMESPACE STD SEMICOLON 
    {: env = new SymbolTable (null); /* start new scope */ :}
    externalDefinitionList {: RESULT = env; :} ;

externalDefinitionList ::= externalDefinition 
  | externalDefinitionList externalDefinition ;

externalDefinition ::= functionDefinition | declaration ;

functionDefinition ::= 
    simpleTypeName:type functionId:id 
    {:
      currentEnv = env;         	  /* save current env */
      env = new SymbolTable (currentEnv); /* start new scope */
    :}
    LPAREN argumentDeclarationListOption RPAREN 
    {:
      currentEnv . enterFunc (id, type, env); /* to allow recursive calls */
    :}
    LBRACE 
    declaratorList statementListOption RETURN expression SEMICOLON RBRACE 
    {: 
      currentEnv . enterFuncCode (id, ""); /* add code to function entry */
      env = env . parent (); /* restore env */ 
    :} ;

declaration ::= classSpecifier SEMICOLON 
  | declarator:decl SEMICOLON 
    {:
      env . enterVar (decl . id (), decl . type ());
    :} ;

simpleTypeName ::= 
    classId:id {: RESULT = new ObjectType (id, env . entry (id)); :}
  | INT {: RESULT = new IntegerType (); :} ;

declaratorList ::= 
    declaratorList declarator:decl SEMICOLON 
    {:
      env . enterVar (decl . id (), decl . type ());
    :}
  | ;

declarator ::= 
    simpleTypeName:type objectId:id 
    {: 
      RESULT = new Declarator (id, type); 
    :}
  | declarator:decl LBRACK INTEGER:dimension RBRACK 
    {:
      RESULT = new Declarator (decl . id (), 
        new ArrayType (Integer . parseInt (dimension), decl . type ()));
    :} ;

argumentDeclarationListOption ::= argumentDeclarationList | ;

argumentDeclarationList ::= 
    argumentDeclarationList COMMA declarator:decl
    {:
      env . enterVar (decl . id (), decl . type ());
    :}
  | declarator:decl
    {:
      env . enterVar (decl . id (), decl . type ());
    :} ;

classSpecifier ::= 
    CLASS classId:id LBRACE RBRACE 
      {: env . enterClass (id, new SymbolTable (env)); :}
  | CLASS classId:id LBRACE
      {:
        currentEnv = env;                   /* save current env */
        env = new SymbolTable (currentEnv); /* start new scope */
        currentEnv . enterClass (id, env);
      :}
    PUBLIC COLON memberList RBRACE 
      {:
        env = env . parent (); /* restore env */
      :} ;


memberList ::= memberList memberDeclaration | memberDeclaration ;

memberDeclaration ::= 
    declarator:decl SEMICOLON 
    {:
      env . enterVar (decl . id (), decl . type ());
    :}
  | functionDefinition ;

statement ::= compoundStatement 
  | assignmentStatement SEMICOLON 
  | CIN INPUT variable SEMICOLON
  | COUT OUTPUT expression SEMICOLON
  | IF LPAREN expression RPAREN statement elseOption
  | WHILE LPAREN expression RPAREN statement ;

compoundStatement ::= LBRACE statementList RBRACE ;

statementListOption ::= statementList | ;

statementList ::= statementList statement | statement ;

assignmentStatement ::= variable ASSIGN expression ;

elseOption ::= ELSE statement | ;

expression ::= expression OR andExpression | andExpression ;

andExpression ::= andExpression AND relationalExpression
  | relationalExpression ;

relationalExpression ::= 
    relationalExpression relationalOperator arithmeticExpression
  | arithmeticExpression ;

relationalOperator ::= LT | LE | GT | GE | EQ | NE ;

arithmeticExpression ::= term | arithmeticExpression addingOperator term ;

addingOperator ::= PLUS | MINUS ;

term ::= factor | term multiplyingOperator factor ;

multiplyingOperator ::= TIMES | SLASH ;

factor ::= primaryExpression | unaryOperator factor ;

unaryOperator ::= addingOperator | NOT ;

primaryExpression ::= variable | INTEGER | LPAREN expression RPAREN ;

variable ::= classMember | variable DOT classMember ;

classMember ::= objectId subscriptList | functionCall ;

subscriptList ::= subscriptList LBRACK expression RBRACK | ;

functionCall ::= functionId LPAREN expressionListOption RPAREN 
  | object DOT functionId LPAREN expressionListOption RPAREN ; 

expressionListOption ::= expressionList | ;

expressionList ::= expressionList COMMA expression | expression ;

classId ::= ID:id {: RESULT = id; :} ;

objectId ::= ID:id {: RESULT = id; :} ;

functionId ::= ID:id {: RESULT = id; :} ;
